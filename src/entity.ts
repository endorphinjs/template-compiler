import { Builder, BuilderContext } from './builder';
import CompileState from './compile-state';
import { Chunk, ChunkList } from './utils';
import ElementContext from './element-context';

type RenderContext = 'create' | 'update' | 'destroy';
type EntityType = 'element' | 'text' | 'block';

interface RenderModel {
    code: ChunkList | null;
    injector?: boolean;
    scope?: boolean;
    entity?: boolean;
}

type RenderResult = {
    [K in RenderContext]?: RenderModel
}

/**
 * Entity is an object generated by runtime. It could be a DOM element, block,
 * iterator etc. Every object must be created and optionally updated and destroyed.
 */
export default class Entity {
    private cache?: RenderResult;

    /**
     * @param type Entity type, describes how entity should be attached to parent
     * @param symbol Variable name (symbol) for referencing current entity
     * @param create Builder function that generates code for creating entity
     * @param update Builder function that generates code for updating entity
     * @param destroy Builder function that generates code for destroying entity
     */
    constructor(readonly type: EntityType,
                public symbol: string,
                public create?: Builder,
                public update?: Builder,
                public destroy?: Builder) {
    }

    /** Check if entity was already rendered */
    get rendered() {
        return !!this.cache;
    }

    /**
     * Renders current entity. Render result is cached for later reuse
     */
    render(state: CompileState, elemCtx?: ElementContext): RenderResult {
        const entity = this;
        let rendering: RenderContext;

        const result: RenderResult = {
            create: { code: null },
            update: { code: null },
            destroy: { code: null }
        };

        const ctx: BuilderContext = {
            state,
            host() {
                return state.options.host;
            },
            entity() {
                result[rendering].entity = true;
                return entity.symbol;
            },
            injector() {
                result[rendering].injector = true;
                return elemCtx ? elemCtx.injector : 'injector';
            },
            scope() {
                // In most cases, `scope` is passed as argument of every function
                result[rendering].scope = true;
                return state.options.scope;
            },
            store(name) {
                return state.useStore(name);
            }
        };

        const render = (name: RenderContext): Chunk[] | null => {
            const builder = this[rendering = name];
            return builder ? builder(ctx) : null;
        };

        result.create.code = render('create');
        result.update.code = render('update');
        result.destroy.code = render('destroy');

        return result;
    }
}
